Description: "Deploy FSxN Report."
#
# This just formats the page that prompts for the parameters when using the AWS Console to deploy your stack.
Metadata: 
  AWS::CloudFormation::Interface: 
    ParameterGroups:
      - Label: 
          default: "Deployment Parameters"
        Parameters: 
          - emailTo
          - emailFrom
          - reportType
          - frequency
          - regions
          - allRegions
          - roleArn

    ParameterLabels:
      emailTo:
        default: "The AWS SES identity to send the report to."
      emailFrom:
        default: "The AWS SES identity to send the report from."
      reportType:
        default: "The type of report."
      frequency:
        default: "The frequency of the report."
      regions:
        default: "A comma separated list of AWS regions you want the program to look for FSxN file system from."
      allRegions:
        default: "If set to 'True' the program will look for FSxN file systems in all AWS regions."
      roleArn:
        default: "The ARN of an existing IAM role that has the permissions list in the documentation."

Parameters:
  emailTo:
    Description: "The AWS SES identity to send the report to."
    Type: String

  emailFrom:
    Description: "The AWS SES identity to send the report from."
    Type: String

  reportType:
    Description: "The type of report. Allowed values are 'text' or 'html'."
    Type: String
    Default: "html"
    AllowedValues: ["text", "html"]

  frequency:
    Description: "The frequency of the report. Allowed values are 'daily', 'weekly', or 'monthly'."
    Type: String
    Default: "weekly"
    AllowedValues: ["daily", "weekly", "monthly"]

  regions:
    Description: "A comma separated list of AWS regions you want the program to look for FSxN file system from. The default is to just scan the region the program is running in, or all regions if 'allRegions' is set to 'True' and this field is left empty."
    Type: CommaDelimitedList
    Default: ""

  allRegions:
    Description: "If set to 'True' the program will look for FSxN file systems in all AWS regions. If set to 'False' it will only look in the regions specified in the 'regions' parameter."
    Type: String
    Default: "False"
    AllowedValues: ["True", "False"]

  roleArn:
    Description: "The ARN of an existing IAM role that has the permissions list in the documentation. If not set, the CloudFormation template will create a new role with the required permissions."
    Type: String
    Default: ""

Conditions:
  createRole: !Equals [!Ref roleArn, ""]
  createDailySchedule: !Equals [!Ref frequency, "daily"]
  createWeeklySchedule: !Equals [!Ref frequency, "weekly"]
  createMonthlySchedule: !Equals [!Ref frequency, "monthly"]

Resources:
  LambdaEventRuleDaily:
    Type: "AWS::Events::Rule"
    Condition: createDailySchedule
    Properties:
      Description: "Event rule to trigger the FSxN Report Lambda function."
      Name: !Sub "FSxN_Report-${AWS::StackName}"
      ScheduleExpression: "cron(0 0 * * ? *)"
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaFunction.Arn
          Id: "FSxNReportLambdaTarget"

  LambdaEventRuleWeekly:
    Type: "AWS::Events::Rule"
    Condition: createWeeklySchedule
    Properties:
      Description: "Event rule to trigger the FSxN Report Lambda function."
      Name: !Sub "FSxN_Report-${AWS::StackName}"
      ScheduleExpression: "cron(0 0 ? * 2 *)"
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaFunction.Arn
          Id: "FSxNReportLambdaTarget"

  LambdaEventRuleMonthly:
    Type: "AWS::Events::Rule"
    Condition: createMonthlySchedule
    Properties:
      Description: "Event rule to trigger the FSxN Report Lambda function."
      Name: !Sub "FSxN_Report-${AWS::StackName}"
      ScheduleExpression: "cron(0 0 1 * ? *)"
      State: "ENABLED"
      Targets:
        - Arn: !GetAtt LambdaFunction.Arn
          Id: "FSxNReportLambdaTarget"

  LambdaPermissionEventRuleDaily:
    Type: "AWS::Lambda::Permission"
    Condition: createDailySchedule
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName: !GetAtt LambdaFunction.Arn
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt LambdaEventRuleDaily.Arn

  LambdaPermissionEventRuleWeekly:
    Type: "AWS::Lambda::Permission"
    Condition: createWeeklySchedule
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName: !GetAtt LambdaFunction.Arn
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt LambdaEventRuleWeekly.Arn

  LambdaPermissionEventRuleMonthly:
    Type: "AWS::Lambda::Permission"
    Condition: createMonthlySchedule
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName: !GetAtt LambdaFunction.Arn
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt LambdaEventRuleMonthly.Arn

  LambdaRole:
    Type: "AWS::IAM::Role"
    Condition: createRole
    Properties:
      RoleName: !Sub "FSxN_Report-${AWS::StackName}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"

      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"

      Policies:
        - PolicyName: "LambdaPolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "fsx:DescribeFileSystems"
                  - "fsx:DescribeVolumes"
                  - "fsx:DescribeStorageVirtualMachines"
                  - "cloudwatch:GetMetricData"
                  - "ec2:DescribeRegions"
                Resource: "*"

              - Effect: "Allow"
                Action:
                  - "ses:SendEmail"
                Resource:
                  - !Sub "arn:aws:ses:*:${AWS::AccountId}:identity/*"
                  - !Sub "arn:aws:ses:*:${AWS::AccountId}:configuration-set/*"

  LambdaFunction:
    Type: "AWS::Lambda::Function"
    Properties:
      FunctionName: !Sub "FSxN_Report-${AWS::StackName}"
      Role: !If [createRole, !GetAtt LambdaRole.Arn, !Ref roleArn]
      PackageType: "Zip"
      Runtime: "python3.13"
      Handler: "index.lambda_handler"
      Timeout: 300
      Environment:
        Variables:
          TO_ADDRESS: !Ref emailTo
          FROM_ADDRESS: !Ref emailFrom
          REPORT_TYPE: !Ref reportType
          REGIONS: !Join [",", !Ref regions]
          ALL_REGIONS: !Ref allRegions

      Code:
        ZipFile: |
          #!/bin/python3
          #
          ################################################################################
          # This script is used to create a report of all the FSx for ONTAP file systems
          # in the AWS account. It will list all the file systems, SVMs, and volumes
          # along with their usage information.
          #
          # By default it will generate an HTML report of all the FSx for ONTAP file
          # systems witin the default aws region. However, it can be configured to report
          # on all the FSx for ONTAP file systems in all of the AWS regions, or a specific
          # set of regions. It can generate either an HTML or text based report.
          #
          # The following environment variables are used to configure the script:
          #   ALL_REGIONS: If set to 'true', the script will report on all the FSxN in
          #               all regions.
          #   REGIONS: A comma-separated list of regions report on.
          #   REPORT_TYPE: If set to 'text', the script will generate a text report. If
          #               set to anything else, it will generate an HTML report.
          #   TO_ADDRESS: The email address to send the report to. If not set, the report
          #              will be output to the console.
          #   FROM_ADDRESS: The email address to send the report from. If not set, the
          #                report will be output to the console.
          ################################################################################
          
          import boto3
          from botocore.config import Config
          from datetime import datetime, timedelta
          import os
          
          ################################################################################
          # This function is used to get the value of a tag by its key. It returns 'N/A'
          # if the tag is not found.
          ################################################################################
          def getTag(key, tags):
              for tag in tags:
                  if tag['Key'] == key:
                      return tag['Value']
              return 'N/A'
          
          ################################################################################
          # This function is used to obtain all the information about the FSx for ONTAP
          # including its configuration and usage information.
          ################################################################################
          def getFSxNInfo(region):
              global fsxns, svms, volumes, volumeUsageInfo, fsxnUsageInfo
          
              fsxns = []
              svms = []
              volumes = []
              #
              # Initialize the FSx client
              fsxClient = boto3.client('fsx', region_name=region)
              cwClient = boto3.client('cloudwatch', region_name=region)
              #
              # Retrieve all FSx for ONTAP file systems
              fsxnData = fsxClient.describe_file_systems()
              for fsxn in fsxnData['FileSystems']:
                  if fsxn['FileSystemType'] == 'ONTAP':
                      fsxns.append(fsxn)
              nextToken = fsxnData.get('NextToken')
              while nextToken:
                  fsxnData = fsxClient.describe_file_systems(NextToken=nextToken)
                  for fsxn in fsxnData['FileSystems']:
                      if fsxn['FileSystemType'] == 'ONTAP':
                          fsxns.append(fsxn)
                  nextToken = fsxnData.get('NextToken')
              #
              # Retrieve all the FSxN usage information
              fsxnUsageInfo = {}
              metrics = []
              count = 0
              for fsxn in fsxns:
                  fsxnId = fsxn['FileSystemId']
                  count += 1
                  metrics.append({
                              "Id": f"{fsxnId.replace('fs-', 'm_')}",
                              "MetricStat": {
                                  "Metric": {
                                      "Namespace": "AWS/FSx",
                                      "MetricName": "StorageUsed",
                                      "Dimensions": [
                                      {
                                          "Name": "FileSystemId",
                                          "Value": fsxnId
                                      },
                                      {
                                          "Name": "StorageTier",
                                          "Value": "SSD"
                                      },
                                      {
                                          "Name": "DataType",
                                          "Value": "All"
                                      }]
                                  },
                                  "Period": 300,
                                  "Stat": "Average"
                              },
                              "ReturnData": True
                           })
                  if count > 100:
                      response = cwClient.get_metric_data(MetricDataQueries=metrics,
                          StartTime=datetime.now() - timedelta(minutes=10),
                          EndTime=datetime.now())
                      for metric in response['MetricDataResults']:
                          fsxnId = metric['Id'].replace('m_', 'fs-')
                          fsxnUsageInfo[fsxnId] = {
                                  'UsedCapacity': metric['Values'][0] if len(metric['Values']) > 0 else 'N/A',
                                  'StorageCapacity': fsxn['StorageCapacity']}
                      count = 0
                      metrics = []
          
              if count > 0:
                  response = cwClient.get_metric_data(MetricDataQueries=metrics,
                      StartTime=datetime.now() - timedelta(minutes=10),
                      EndTime=datetime.now())
                  for metric in response['MetricDataResults']:
                      fsxnId = metric['Id'].replace('m_', 'fs-')
                      fsxnUsageInfo[fsxnId] = {
                              'UsedCapacity': metric['Values'][0] if len(metric['Values']) > 0 else 'N/A',
                              'StorageCapacity': fsxn['StorageCapacity']}
              #
              # Retrieve all the SVMs
              svmsData = fsxClient.describe_storage_virtual_machines()
              for svm in svmsData['StorageVirtualMachines']:
                  svms.append(svm)
              next = svmsData.get('NextToken')
              while next:
                  svmsData = fsxClient.describe_storage_virtual_machines(NextToken=next)
                  for svm in svmsData['StorageVirtualMachines']:
                      svms.append(svm)
                  next = svmsData.get('NextToken')
              #
              # Retrieve all the FSx for ONTAP volumes
              volumesData = fsxClient.describe_volumes()
              for volume in volumesData['Volumes']:
                  if volume.get('OntapConfiguration') is not None:
                      volumes.append(volume)
              next = volumesData.get('NextToken')
              while next:
                  volumesData = fsxClient.describe_volumes(NextToken=next)
                  for volume in volumesData['Volumes']:
                      if volume.get('OntapConfiguration') is not None:
                          volumes.append(volume)
                  next = volumesData.get('NextToken')
              #
              # Sort the volumes by name.
              volumes.sort(key=lambda k: k["Name"].lower())
              #
              # Retrieve the volume usage metrics.
              volumeUsageInfo = {}
              metrics = []
              count=0
              for volume in volumes:
                  volId = volume['VolumeId']
                  fsxnId = volume['FileSystemId']
                  count+=1
                  for metric in ['StorageCapacity', 'FilesUsed', 'FilesCapacity']:
                      metrics.append({
                              "Id": f"{volId.replace('fsvol-', 'm_')}_{metric}",
                              "MetricStat": {
                                  "Metric": {
                                      "Namespace": "AWS/FSx",
                                      "MetricName": metric,
                                      "Dimensions": [
                                      {
                                          "Name": "FileSystemId",
                                          "Value": fsxnId
                                      },
                                      {
                                          "Name": "VolumeId",
                                          "Value": volId
                                      }]
                                  },
                                  "Period": 300,
                                  "Stat": "Average"
                              },
                              "ReturnData": True
                           })
                  for dataType in ['User', 'Other', 'Snapshot']:
                      metrics.append({
                              "Id": f"{volId.replace('fsvol-', 'm_')}_StorageUsed_{dataType}",
                              "MetricStat": {
                                  "Metric": {
                                      "Namespace": "AWS/FSx",
                                      "MetricName": "StorageUsed",
                                      "Dimensions": [
                                      {
                                          "Name": "FileSystemId",
                                          "Value": fsxnId
                                      },
                                      {
                                          "Name": "VolumeId",
                                          "Value": volId
                                      },
                                      {
                                          "Name": "StorageTier",
                                          "Value": "All"
                                      },
                                      {
                                          "Name": "DataType",
                                          "Value": dataType
                                      }]
                                  },
                                  "Period": 300,
                                  "Stat": "Average"
                              },
                              "ReturnData": True
                          })
          
                  if count > 70:
                      response = cwClient.get_metric_data(MetricDataQueries=metrics,
                          StartTime=datetime.now() - timedelta(minutes=10),
                          EndTime=datetime.now())
                      for metric in response['MetricDataResults']:
                          volumeUsageInfo[metric['Id']] = metric
                      count=0
                      metrics = []
          
              if count > 0:
                  response = cwClient.get_metric_data(MetricDataQueries=metrics,
                      StartTime=datetime.now() - timedelta(minutes=10),
                      EndTime=datetime.now())
                  for metric in response['MetricDataResults']:
                      volumeUsageInfo[metric['Id']] = metric
          ################################################################################
          # This function is used to generate a html version of the report.
          ################################################################################
          def generateHTMLReport(region):
              global fsxns, svms, volumes, volumeUsageInfo, fsxnUsageInfo
          
              if len(fsxns) == 0:
                  return ""
          
              htmlBody = '<table style="border-collapse: collapse;">\n'
              tableCellStyle = "border: 1px solid black; padding-top: 2px; padding-bottom: 2px; padding-left: 5px; padding-right: 5px"
              
              for fsxn in fsxns:
                  fsxnId = fsxn['FileSystemId']
                  name = getTag('Name', fsxn.get('Tags', []))
                  ontapConfig = fsxn['OntapConfiguration']
                  if fsxnUsageInfo[fsxnId]['UsedCapacity'] != 'N/A' :
                      fileSystemUsedCapacity = int(fsxnUsageInfo[fsxnId]['UsedCapacity']/1024/1024/1024)
                      percentUsed = f"{((fileSystemUsedCapacity / fsxn['StorageCapacity']) * 100):.2f}%"
                      fileSystemUsedCapacity = f"{fileSystemUsedCapacity}GB"
                  else:
                      fileSystemUsedCapacity = 'N/A'
                      percentUsed = 'N/A'
                  htmlBody += f'<tr><td colspan=11 style="{tableCellStyle}"><b>ID:</b> {fsxnId}<br>\n'
                  htmlBody += f"<b>Name:</b> {name}<br>\n"
                  htmlBody += f"<b>Region:</b> {region}<br>\n"
                  htmlBody += f"<b>Availability:</b> {ontapConfig['DeploymentType']}<br>\n"
                  htmlBody += f"<b>Provisioned Performance Tier Storage:</b> {fsxn['StorageCapacity']}GB<br>\n"
                  htmlBody += f"<b>Used Performance Tier Storage:</b> {fileSystemUsedCapacity}<br>\n"
                  htmlBody += f"<b>Percent Used Performance Tier:</b> {percentUsed}<br>\n"
                  htmlBody += "</td></tr>\n"
                  htmlBody += f'<tr><td colspan=11 style="{tableCellStyle}"><b>Volumes:</b></td></tr>\n'
                  htmlBody += f'<tr><th style="{tableCellStyle}">Name</th><th style="{tableCellStyle}">SVM</th><th style="{tableCellStyle}">ID</th>\n'
                  htmlBody += f'<th style="{tableCellStyle}">Tiering Policy</th><th style="{tableCellStyle}">Type</th><th style="{tableCellStyle}">Volume Style</th>\n'
                  htmlBody += f'<th style="{tableCellStyle}">Security Type</th><th style="{tableCellStyle}">Storage Capacity(MB)</th><th style="{tableCellStyle}">Storage Utilization</th>\n'
                  htmlBody += f'<th style="{tableCellStyle}">Files Capacity</th><th style="{tableCellStyle}">Files Utilization</th></tr>\n'
                  for volume in volumes:
                      if volume['FileSystemId'] == fsxnId:
                          volId = volume['VolumeId']
                          ontapConfig = volume['OntapConfiguration']
                          volumeCapacity = volumeUsageInfo[volId.replace("fsvol-", 'm_') + '_StorageCapacity']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", 'm_') + '_StorageCapacity']['Values']) > 0 else 0
                          volumeUsed = volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_User']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_User']['Values']) > 0 else 0
                          volumeUsed += volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_Other']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_Other']['Values']) > 0 else 0
                          volumeUsed += volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_Snapshot']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_Snapshot']['Values']) > 0 else 0
                          volumePercentUsed = f"{((volumeUsed / volumeCapacity) * 100):.2f}%" if volumeCapacity > 0 else 'N/A'
                          volumeFilesUsed = volumeUsageInfo[volId.replace("fsvol-", "m_") +  '_FilesUsed']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", "m_") +  '_FilesUsed']['Values']) > 0 else 0
                          volumeFilesCapacity = volumeUsageInfo[volId.replace("fsvol-", "m_") +  '_FilesCapacity']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", "m_") +  '_FilesCapacity']['Values']) > 0 else 0
                          volumeFilesPercentUsed = f"{((volumeFilesUsed / volumeFilesCapacity) * 100):.2f}%" if volumeFilesCapacity > 0 else 'N/A'
                          securityStyle = ontapConfig.get('SecurityStyle', 'N/A')
                          htmlBody += f'<tr><td align="right" style="{tableCellStyle}">{volume["Name"]}</td><td align="right" style="{tableCellStyle}">{ontapConfig["StorageVirtualMachineId"]}</td>\n'
                          htmlBody += f'<td align="right" style="{tableCellStyle}">{volume["VolumeId"]}</td><td align="right" style="{tableCellStyle}">{ontapConfig["TieringPolicy"]["Name"]}</td>\n'
                          htmlBody += f'<td align="right" style="{tableCellStyle}">{ontapConfig["OntapVolumeType"]}</td>\n'
                          htmlBody += f'<td align="right" style="{tableCellStyle}">{ontapConfig["VolumeStyle"]}</td><td align="right" style="{tableCellStyle}">{securityStyle}</td>\n'
                          htmlBody += f'<td align="right" style="{tableCellStyle}">{int(volumeCapacity/1024/1024)}</td><td align="right" style="{tableCellStyle}">{volumePercentUsed}</td>\n'
                          htmlBody += f'<td align="right" style="{tableCellStyle}">{int(volumeFilesCapacity)}</td><td align="right" style="{tableCellStyle}">{volumeFilesPercentUsed}</td></tr>\n'
                  htmlBody += f'<tr><td style="{tableCellStyle}"> </td></tr>\n'
              htmlBody += "</table>\n"
              htmlBody += "<br><br>\n"
          
              return htmlBody
          
          ################################################################################
          # This function is used to generate a text version of the report.
          ################################################################################
          def generateTextReport(region):
              global fsxns, svms, volumes, volumeUsageInfo, fsxnUsageInfo
              #
              # Generate the report.
              textReport = f"File Systems in {region}:\n"
              for fsxn in fsxns:
                  indent = ' ' * 4
                  fsxnId = fsxn['FileSystemId']
                  textReport += f"{indent}File System ID: {fsxnId}\n"
                  name = getTag('Name', fsxn.get('Tags', []))
                  textReport += f"{indent}Name: {name}\n{indent}Status: {fsxn['Lifecycle']}\n{indent}VPC: {fsxn['VpcId']}\n{indent}Subnet(s): "
                  for subnet in fsxn['SubnetIds']:
                      textReport += f"{subnet} "
                  ontapConfig = fsxn['OntapConfiguration']
                  textReport += f"\n{indent}Deployment Type: {ontapConfig['DeploymentType']}\n{indent}Number of HA pairs: {ontapConfig['HAPairs']}\n"
                  textReport += f"{indent}Management IP: {ontapConfig['Endpoints']['Management']['IpAddresses'][0]}\n"
                  textReport += f"{indent}Throughput Capacity: {ontapConfig['ThroughputCapacity']}\n{indent}IOPS Capacity: {ontapConfig['DiskIopsConfiguration']['Iops']}\n"
                  backupConfig = fsxn.get('AutomaticBackupRetentionDays', 'N/A')
                  textReport += f"{indent}Backup Configuration: {backupConfig}\n{indent}Maintenance Schedule: {ontapConfig['WeeklyMaintenanceStartTime']}\n"
                  textReport += f"{indent}Provisioned Capacity: {fsxn['StorageCapacity']}GB\n"
                  if fsxnUsageInfo[fsxnId]['UsedCapacity'] != 'N/A' :
                      fileSystemUsedCapacity = int(fsxnUsageInfo[fsxnId]['UsedCapacity']/1024/1024/1024)
                      percentUsed = f"{((fileSystemUsedCapacity / fsxn['StorageCapacity']) * 100):.2f}%"
                      fileSystemUsedCapacity = f"{fileSystemUsedCapacity}GB"
                  else:
                      fileSystemUsedCapacity = 'N/A'
                      percentUsed = 'N/A'
                  textReport += f"{indent}Used Capacity: {fileSystemUsedCapacity}\n"
                  textReport += f"{indent}Percent Capacity Used: {percentUsed}\n"
          
                  textReport += f"{indent}Storage Virtual Machines:\n"
                  for svm in svms:
                      indent=' ' * 8
                      if svm['FileSystemId'] != fsxn['FileSystemId']:
                          continue
          
                      svmId = svm['StorageVirtualMachineId']
                      textReport += f"{indent}ID: {svmId}\n{indent}Name: {svm['Name']}\n{indent}Status: {svm['Lifecycle']}\n"
                      textReport += f"{indent}Data/Management IP: {svm['Endpoints']['Management']['IpAddresses'][0]}\n{indent}iSCSI IP: {svm['Endpoints']['Iscsi']['IpAddresses'][0]}\n"
                      textReport += f"{indent}Volumes:\n"
                      for volume in volumes:
                          indent = ' ' * 12
                          if volume['OntapConfiguration']['StorageVirtualMachineId'] != svmId:
                              continue
                          volId = volume['VolumeId']
                          ontapConfig = volume['OntapConfiguration']
                          securityStyle = ontapConfig.get('SecurityStyle', 'N/A')
                          textReport += f"{indent}ID: {volume['VolumeId']}\n{indent}Name: {volume['Name']}\n{indent}Status: {volume['Lifecycle']}\n"
                          textReport += f"{indent}Security Style: {securityStyle}\n{indent}Tiering Policy: {ontapConfig['TieringPolicy']['Name']}\n"
                          textReport += f"{indent}Replication Type: {ontapConfig['OntapVolumeType']}\n{indent}Snapshot Policy: {ontapConfig['SnapshotPolicy']}\n{indent}Type: {ontapConfig['VolumeStyle']}\n"
                          volumeCapacity = volumeUsageInfo[volId.replace("fsvol-", 'm_') + '_StorageCapacity']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", 'm_') + '_StorageCapacity']['Values']) > 0 else 0
                          volumeUsed = volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_User']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_User']['Values']) > 0 else 0
                          volumeUsed += volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_Other']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_Other']['Values']) > 0 else 0
                          volumeUsed += volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_Snapshot']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", "m_") + '_StorageUsed_Snapshot']['Values']) > 0 else 0
                          volumePercentUsed = f"{((volumeUsed / volumeCapacity) * 100):.2f}%" if volumeCapacity > 0 else 'N/A'
                          volumeFilesUsed = volumeUsageInfo[volId.replace("fsvol-", "m_") +  '_FilesUsed']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", "m_") +  '_FilesUsed']['Values']) > 0 else 0
                          volumeFilesCapacity = volumeUsageInfo[volId.replace("fsvol-", "m_") +  '_FilesCapacity']['Values'][0] if len(volumeUsageInfo[volId.replace("fsvol-", "m_") +  '_FilesCapacity']['Values']) > 0 else 0
                          volumeFilesPercentUsed = f"{((volumeFilesUsed / volumeFilesCapacity) * 100):.2f}%" if volumeFilesCapacity > 0 else 'N/A'
                          textReport += f"{indent}Capacity: {int(volumeCapacity/1024/1024)}M\n{indent}Used Capacity: {int(volumeUsed/1024/1024)}M\n{indent}Percent Capacity Used: {volumePercentUsed}\n"
                          textReport += f"{indent}Files Capacity: {int(volumeFilesCapacity)}\n{indent}Files Used: {int(volumeFilesUsed)}\n{indent}Percent Files Used: {volumeFilesPercentUsed}\n"
                          textReport += "\n"
                      textReport += "\n"
                  textReport += "\n"
          
              return textReport
          
          ################################################################################
          # This function is used to email the report.
          ################################################################################
          def emailReport(report, fromAddress, toAddress, reportType):
          
              sesClient = boto3.client('ses')
              sesClient.send_email(
                              Destination={
                                  'ToAddresses': [
                                      toAddress
                                  ]
                              },
                              Message= {
                                  'Body': {
                                      reportType: {
                                          'Data': report,
                                      }
                                  },
                                  'Subject': {
                                      'Charset': 'UTF-8',
                                      'Data': "FSxN Report",
                                  }
                              },
                              Source=fromAddress
                          )
          
          ################################################################################
          # This function is used to get the configuration from the environment variables.
          ################################################################################
          def getConfig():
              global config
              #
              config = {
                  "AWS_REGION": None,
                  "ALL_REGIONS": None,
                  "REGIONS": None,
                  "REPORT_TYPE": None,
                  "TO_ADDRESS": None,
                  "TEXT_REPORT": None,
                  "FROM_ADDRESS": None
              }
              #
              # Get the paramaters from the environment.
              for var in config:
                  config[var] = os.environ.get(var)
                  #
                  # Since CloudFormation set all environment variables to empty strings
                  # set them back to none if they are empty.
                  if config[var] == '':
                      config[var] = None
              #
              # Convert string values to boolean where necessary.
              if config['ALL_REGIONS'] != None:
                  if config['ALL_REGIONS'].lower() == 'true':
                      config['ALL_REGIONS'] = True
                  else:
                      config['ALL_REGIONS'] = False
              #
              # To be backwards compatible, if the TEXT_REPORT variable is set, then
              # set REPORT_TYPE appropriately.
              if config['TEXT_REPORT'] != None and config['REPORT_TYPE'] is None:
                  if config['TEXT_REPORT'].lower() == 'true':
                      config['REPORT_TYPE'] = "Text"
                  else:
                      config['REPORT_TYPE'] = "Html"
              #
              # Since the API is case sensitive, make sure the REPORT_TYPE is set to
              # either 'Text' or 'Html'.
              if config['REPORT_TYPE'] is not None:
                  if config['REPORT_TYPE'].lower() == 'text':
                      config['REPORT_TYPE'] = 'Text'
                  else:
                      config['REPORT_TYPE'] = 'Html'
              else:
                  config['REPORT_TYPE'] = 'Html'
          
          ################################################################################
          ################################################################################
          def lambda_handler(event, context):
              global config, boto3Config
              #
              # Configure boto3 to use the more advanced "adaptive" retry method.
              boto3Config = Config(
                  retries = {
                      'max_attempts': 5,
                      'mode': 'adaptive'
                  }
              )
          
              getConfig()
              regions = []
          
              if calledAsLambda:
                  if config['TO_ADDRESS'] is None or config['FROM_ADDRESS'] is None:
                      raise Exception("Both 'toAddress' and 'fromAddress' environment variables must be set for email reporting.")
          
              if config['REGIONS'] is not None:
                  regions = config['REGIONS'].split(',')
                  i=0
                  while i < len(regions):
                      regions[i] = regions[i].strip()
                      i += 1
              elif config['ALL_REGIONS']:
                  ec2Client = boto3.client('ec2', config=boto3Config)
                  ec2Regions = ec2Client.describe_regions()['Regions']
                  for region in ec2Regions:
                      regions += [region['RegionName']]
              else:
                  if config['AWS_REGION'] is not None:
                      regions = [config['AWS_REGION']]
                  else:
                      regions = [boto3.Session().region_name]
          
              fsxRegions = boto3.Session().get_available_regions('fsx')
              report = ""
              #
              # For an HTML report, just want the HTML start and end data once for all the regions.
              if config['REPORT_TYPE'].lower() != "text":
                  currentReport = "<!DOCTYPE html>\n<html>\n"
                  currentReport += "<head>\n<title>FSxN Report</title>\n"
                  currentReport += "</head>\n<body>\n"
          
              for region in regions:
                  if region in fsxRegions:
                      #
                      # Get all the FSxN information.
                      getFSxNInfo(region)
                      #
                      # Generate the report.
                      if config['REPORT_TYPE'].lower() == 'text':
                          currentReport = generateTextReport(region)
                      else:  # Default to an HTML report.
                          currentReport += generateHTMLReport(region)
          
                      if len(currentReport) > maxEmailSize:
                          raise Exception(f"Report for region {region} exceeds maximum email size of {maxEmailSize} characters.")
          
                      if len(report) + len(currentReport) > maxEmailSize:
                          emailReport(report, config['FROM_ADDRESS'], config['TO_ADDRESS'], config['REPORT_TYPE'])
                          report = currentReport
                          currentReport = ""
                      else:
                          report += currentReport
                          currentReport = ""
          
              if config['REPORT_TYPE'].lower() != 'text':
                  report += "</body></html>\n"
              #
              # Email the report.
              if config['TO_ADDRESS'] is None or config['FROM_ADDRESS'] is None:
                  print(report)
              else:
                  emailReport(report, config['FROM_ADDRESS'], config['TO_ADDRESS'], config['REPORT_TYPE'])
          
          ################################################################################
          ################################################################################
          #
          # If this script is not running as a Lambda function, then call the lambda_handler function.
          calledAsLambda = True
          maxEmailSize = (1024*1024*5) # The SES version 1 is 5MB. SES version 2 is 10MB.
          if os.environ.get('AWS_LAMBDA_FUNCTION_NAME') == None:
              calledAsLambda = False
              lambda_handler(None, None)
